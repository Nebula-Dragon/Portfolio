The 'Mackerel Engine' was the main group project I did for my masters year, which involved creating a working game engine. This was a major project that lasted a whole semester and there were six of us in the group. We ended up getting a 1st for it. 

The source code can be found at: https://github.com/Italia2407/Mackerel-Engine

## What We Did
It was too much to create something of the scope of Unity or Unreal so we set ourselves to creating a middleware game engine specialised for creating solely 3D platformer games. This included rendering, lighting, physics, game logic, entity systems and everything else that could be used to make actual video games with.

Over the months of the semester we went through several stages in the project. First we planned out what features we wanted to implement and did background research on the possible methods and libraries available for those features. Entering the actual development phase, we set out three milestones for development. In the first milestone we focused on rendering and entity systems, as well as an input library, logging, file I/O and storage, and initial set up elements. In the second milestone we continued focusing on entity systems, bring in physics and finish off the renderer, then include scene management, physics, collision detection, memory management and time keeping. In the third milestone we kept working on physics and started work on UI. By the end of all this had a base implementation of an engine, where all the elements worked and we could add more functions, and after that we focused on adding animation, audio, tools for world generation, gameplay, and HUD. 

In each of these milestones, we would volunteer for the features we wanted to work on and we'd pick who would be the leader for it. This method meant that people's contributions were spread around a bit unevenly but also meant people were doing what they really wanted to. This main development phase took the most amount of time and in it we successfully implemented all the main features we set out to, though it took a bit longer than intended and so we didn't get to our stretch goals. Towards the end, we focused on polishing and bug fixing what we had while setting up a basic game as a presentation of what our engine could do, while simultaneously writing up the group report.

For our project we used an agile approach to project management. This means that we would have multiple iterations of development consisting of lanning, developing, and testing, each time adding new functionality or complexity. We kept track of tasks with a kanban board, which we set up on Trello, utilised GitHub (of course) for a shared code base and version control, and Doxygen for our commenting style and documentation.

For my own direct contributions, I first worked on the physics features. I researched possible libraries for us to use, and once we'd decided on which one I helped implement and test the functions that utilised it. When this was done, I helped solve some of the problems that others were having in their own work, though this did not yield commits under my name. Towards the end of the project I volunteered to write up the group project, and in doing so gave up programming tasks. I also researched possible methods for procedural level generation, though we never implemented this as it was a stretch goal.

This was an example image from our final product:
![image](https://github.com/Nebula-Dragon/Portfolio/assets/57454635/092f913c-b76a-48ac-b94f-ee9aa9c85bba)

## What I Learned
### Technical Learnings
The biggest technical thing I learned in the project is how game engines worked. While I always knew that games run off of engines that handle a lot of the physics and graphics for them, I’ve had no idea how these work or what code for them looks like. After the project, I had a much better idea of the many aspects that go into an engine; not just physics and graphics, but also the UI, audio, animation and systems. It also gave me a better idea of not just how they work but how the game developers using the engine will interact with them, with features like physics being components for the developer to use out the box, while features like UI are more like frameworks that the developer can use to make components themselves.

Though I learned a fair bit about how these parts of a video game work technically, I was already somewhat familiar with them conceptually, since they are fairly commonly known. Something I was not familiar with was the background systems of a game. Systems in a game are largely invisible, being just as behind the scenes as the rendering and only noticed when they go wrong. Specifically these include the entity system, scene system, input system, time management system and resource management system, though there could be others. These manage the objects in the game world, the memory resources, keep track of time and user inputs and other such things. I had no experience with these before and very little idea of how they would operate, and though I did not work to implement all of them, being part of the overall process gave me at least some understanding of what it is exactly they do.

Another thing I’ve learned on the technical side about game engines is how they are laid out. This project was the biggest in terms of a codebase that I’d worked on, so how the code was laid out was important to the ease of developing it. The way we structured our project was very intentional; we looked at literature such as Jason Gregory’s Game Engine Architecture and one of our team members' industry experience for an idea of code layout. Thus, the layout of the project we ended up with was a pretty good indicator of what a real engine might be structured like, if not quite as large.

This is important because until then most of my projects had either been my own code structured in a way that made sense to me, projects with a layout already created for me by lecturers, or a group project not nearly as big in team size. None of these were close to an actual professional working environment where code must be structured and laid out for everyone to understand, where they could be many people at different times working on it. So, this project being much closer to a professional layout of code base taught me a lot about what it might actually look like and how it would actually be to work with in a professional environment. 

It turned out that a lot of it is still kept to somewhat of the same layout that lecturers gave out in coursework, which was a bit of a relief and perhaps shouldn’t have been a surprise. Specifically, different systems in the program (like physics and rendering) are grouped into different folders, which are then divided into sub-systems (like the actual rendering process as well as lights and framebuffers for rendering) that are themselves made up of headers identifying the sub-system’s functions and global variables and source files implementing those functions. Meanwhile helper functions are kept in separate folders and external libraries are kept outside the program itself, both with their header files included where they are needed. I was already familiar with this layout, so it’s good to know that it won’t be such a big leap in working processes in industry.
 
### Non-Technical Learnings
As mentioned, while I had worked on group projects and projects with a larger size or time period, this project represents the biggest in all three; team size, scope and project time. Thus, this gave me more experience in this field than I otherwise had. This is especially true given that the previous projects I worked on took place during the pandemic and thus all group activity was entirely online. This was the first big group project where we had to work asynchronously but also met up to have in-person meetings and coding sessions. 

And speaking of the real world, we intentionally structured our team and working methods to be similar to how a real professional team operates, again based on one team member’s real-world knowledge of that. I’m sure it’s clear how invaluable this would be, as it cements this project as giving me some of the best experience of professional development outside of actually working for a software development company. 

I also learned a bit about the project management tools we utilised throughout. I already knew Git as extensively as any programmer would, but task management through Trello was something I didn’t have much familiarity with. I had used it briefly in past projects, but often in those projects we were unsuccessful at sticking to its usage and it often went barebones and eventually abandoned. This time however we were much more successful at using it, keeping up our tracking of tasks from start to finish and providing a nice approximate timeline and list of tasks everyone had achieved. Actually using it properly like this was good in understanding how useful it could really be. 

Another thing similar to that was our documentation style through Doxygen. I had only heard of this method and had no clue how to use it. Once I’d had some instructing, though, and got to write some comments in the doxygen format on a few functions, I began to understand just how useful this documenting tool could be. What’s more, I began to see it in some of the external libraries we’d used here or in courseworks, so this has also likely aided me in understanding future code I encounter.

## Self-Appraisal
Something I’m proud of about this project is how as a group we managed to avoid any significant friction or drama, indeed any at all. Nearly all of us knew each other one way or another before the project began so good relations were present at the start, and I’m happy that these did not wear away over the course of the project. In projects like these it’s quite easy for formerly friendly relationships to turn sour from stress or from annoyances about other people’s work habits, the feeling that somebody isn’t doing enough or is stealing credit, or a number of other reasons. None of these came up at all during our project, we all remained friendly and cooperate and that made the whole thing run much smoother. 

Another point of success I think, in the group as a whole as well as personally, was the success at sticking to the group working plan. We chose to go with an agile approach with regular sprint meetings and by and large we kept up with this. It wasn’t perfect, mind, but we kept to the consistent reports and thus kept pretty good track of where we were, even if that wasn’t always quite where we wanted. Consistently attending the meetings myself meant I was also up-to-date with this, ensuring I didn’t get too lost on the stuff I wasn’t working on.

One particular point of regret in the project, however, is not contributing more consistently to the code base. Looking at the git project, my commits are quite scarce. This is because in early development of the code, work hadn’t begun on any aspects I was very good at or interested in. When these picked up around the middle of development I finally began properly contributing. But then in late development my main contributions were not in the actual program. I had no commits at the end of the project because all of my work was focused on compiling the group report I had volunteered to take the lead on, and also there were many parts of the program I didn’t have a hand in developing so wasn’t very capable to of contributing more to. I don’t regret taking the majority of the writing work since I was very likely the best to do it (and no one else wanted to), but nonetheless I wish that I had contributed more code and had a more visible marker of what I had done.

Another point of regret is how I managed my time. Multiple times throughout the project I found myself heavily swamped by coursework from other modules and ended up dedicating a lot of time to them. I think this was actually a disproportionate amount of time because it left little space for the project. Everyone else also had these coursework commitments but they were able to keep the project in focus at the same time while I mostly went from one target of focus to another. This probably wasn’t a good way of working but this was what I felt most like doing at the time, yet it was likely another reason there isn’t so much of my work visible.

I would note though that this doesn’t mean I fell out of the project. I was always involved and interacting with it, attending meetings and discussing what should be done on topics I had a hand in. But again, this work doesn’t clearly show itself in my code contributions, which are very important. So while I doubt any of my team members would say I wasn’t pulling my weight, I wish I had pulled more weight then I did in the more technical aspects.
