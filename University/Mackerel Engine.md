The 'Mackerel Engine' was the final group project I did for my masters year. It involved creating a working game engine, including rendering, lighting, physics, game logic, entity systems and everything else that could be used to make actual video games with.
This was a major project that lasted a whole semester. In my group of six we planned what we would create, researched what it involved, then programmed different parts in sub-groups and finally wrote the documentation. We ended up getting 73/100, which is a 1st class.

## What We did
We set ourselves to creating a middleware game engine specialised to creating 3D platformer games.

## What I Learned
### Technical Learnings
The biggest technical thing I learned in the project is how game engines worked. While I always knew that games run off of engines that handle a lot of the physics and graphics for them, I’ve had no idea how these work or what code for them looks like. After the project, I had a much better idea of the many aspects that go into an engine; not just physics and graphics, but also the UI, audio, animation and systems. It also gave me a better idea of not just how they work but how the game developers using the engine will interact with them, with features like physics being components for the developer to use out the box, while features like UI are more like frameworks that the developer can use to make components themselves.

Though I learned a fair bit about how these parts of a video game work technically, I was already somewhat familiar with them conceptually, since they are fairly commonly known. Something I was not familiar with was the background systems of a game. Systems in a game are largely invisible, being just as behind the scenes as the rendering and only noticed when they go wrong. Specifically these include the entity system, scene system, input system, time management system and resource management system, though there could be others. These manage the objects in the game world, the memory resources, keep track of time and user inputs and other such things. I had no experience with these before and very little idea of how they would operate, and though I did not work to implement all of them, being part of the overall process gave me at least some understanding of what it is exactly they do.

Another thing I’ve learned on the technical side about game engines is how they are laid out. This project was the biggest in terms of a codebase that I’d worked on, so how the code was laid out was important to the ease of developing it. The way we structured our project was very intentional; we looked at literature such as Jason Gregory’s Game Engine Architecture and one of our team members' industry experience for an idea of code layout. Thus, the layout of the project we ended up with was a pretty good indicator of what a real engine might be structured like, if not quite as large.

This is important because until then most of my projects had either been my own code structured in a way that made sense to me, projects with a layout already created for me by lecturers, or a group project not nearly as big in team size. None of these were close to an actual professional working environment where code must be structured and laid out for everyone to understand, where they could be many people at different times working on it. So, this project being much closer to a professional layout of code base taught me a lot about what it might actually look like and how it would actually be to work with in a professional environment. 

It turned out that a lot of it is still kept to somewhat of the same layout that lecturers gave out in coursework, which was a bit of a relief and perhaps shouldn’t have been a surprise. Specifically, different systems in the program (like physics and rendering) are grouped into different folders, which are then divided into sub-systems (like the actual rendering process as well as lights and framebuffers for rendering) that are themselves made up of headers identifying the sub-system’s functions and global variables and source files implementing those functions. Meanwhile helper functions are kept in separate folders and external libraries are kept outside the program itself, both with their header files included where they are needed. I was already familiar with this layout, so it’s good to know that it won’t be such a big leap in working processes in industry.
 
### Non-Technical Learnings
As mentioned, while I had worked on group projects and projects with a larger size or time period, this project represents the biggest in all three; team size, scope and project time. Thus, this gave me more experience in this field than I otherwise had. This is especially true given that the previous projects I worked on took place during the pandemic and thus all group activity was entirely online. This was the first big group project where we had to work asynchronously but also met up to have in-person meetings and coding sessions. 

And speaking of the real world, we intentionally structured our team and working methods to be similar to how a real professional team operates, again based on one team member’s real-world knowledge of that. I’m sure it’s clear how invaluable this would be, as it cements this project as giving me some of the best experience of professional development outside of actually working for a software development company. 

I also learned a bit about the project management tools we utilised throughout. I already knew Git as extensively as any programmer would, but task management through Trello was something I didn’t have much familiarity with. I had used it briefly in past projects, but often in those projects we were unsuccessful at sticking to its usage and it often went barebones and eventually abandoned. This time however we were much more successful at using it, keeping up our tracking of tasks from start to finish and providing a nice approximate timeline and list of tasks everyone had achieved. Actually using it properly like this was good in understanding how useful it could really be. 

Another thing similar to that was our documentation style through Doxygen. I had only heard of this method and had no clue how to use it. Once I’d had some instructing, though, and got to write some comments in the doxygen format on a few functions, I began to understand just how useful this documenting tool could be. What’s more, I began to see it in some of the external libraries we’d used here or in courseworks, so this has also likely aided me in understanding future code I encounter.

## Self-Appraisal
Something I’m proud of about this project is how as a group we managed to avoid any significant friction or drama, indeed any at all. Nearly all of us knew each other one way or another before the project began so good relations were present at the start, and I’m happy that these did not wear away over the course of the project. In projects like these it’s quite easy for formerly friendly relationships to turn sour from stress or from annoyances about other people’s work habits, the feeling that somebody isn’t doing enough or is stealing credit, or a number of other reasons. None of these came up at all during our project, we all remained friendly and cooperate and that made the whole thing run much smoother. 

Another point of success I think, in the group as a whole as well as personally, was the success at sticking to the group working plan. We chose to go with an agile approach with regular sprint meetings and by and large we kept up with this. It wasn’t perfect, mind, but we kept to the consistent reports and thus kept pretty good track of where we were, even if that wasn’t always quite where we wanted. Consistently attending the meetings myself meant I was also up-to-date with this, ensuring I didn’t get too lost on the stuff I wasn’t working on.

One particular point of regret in the project, however, is not contributing more consistently to the code base. Looking at the git project, my commits are quite scarce. This is because in early development of the code, work hadn’t begun on any aspects I was very good at or interested in. When these picked up around the middle of development I finally began properly contributing. But then in late development my main contributions were not in the actual program. I had no commits at the end of the project because all of my work was focused on compiling the group report I had volunteered to take the lead on, and also there were many parts of the program I didn’t have a hand in developing so wasn’t very capable to of contributing more to. I don’t regret taking the majority of the writing work since I was very likely the best to do it (and no one else wanted to), but nonetheless I wish that I had contributed more code and had a more visible marker of what I had done.

Another point of regret is how I managed my time. Multiple times throughout the project I found myself heavily swamped by coursework from other modules and ended up dedicating a lot of time to them. I think this was actually a disproportionate amount of time because it left little space for the project. Everyone else also had these coursework commitments but they were able to keep the project in focus at the same time while I mostly went from one target of focus to another. This probably wasn’t a good way of working but this was what I felt most like doing at the time, yet it was likely another reason there isn’t so much of my work visible.

I would note though that this doesn’t mean I fell out of the project. I was always involved and interacting with it, attending meetings and discussing what should be done on topics I had a hand in. But again, this work doesn’t clearly show itself in my code contributions, which are very important. So while I doubt any of my team members would say I wasn’t pulling my weight, I wish I had pulled more weight then I did in the more technical aspects.
